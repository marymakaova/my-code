/*
    Пусть есть некоторое число 36. Вот его делители:
    2 3 4 6 9 12 18, где 6 - корень. 
    Идея заключается в том, что при обычном поиске делителей мы идем именно до корня, потому что делители
    после корня включают в себя предыдущие делители (например, число 12 = 2 * 2 * 3). Следовательно, если исходное 
    число n делить на i число (пока делится), то мы гарантированно исключим все делители, кратные i.
    предположим, i = 2. Пока 36 кратно 2 - делим. Следовательно, проделав операцию два раза 
    мы получим нечетное число 9, тем самым исключив четные составные делители и
     записав количество простых двоек в массив. 
     Этот способ гарантирует:
     1. Делить число n мы будем на простое число, так как все его составные делители "уйдут" в процессе деления.
     (например, после деления 36 на 2 получили 9 и на 4 оно уже делиться не будет, так как мы исключили 
     все четные составные делители)
     2. В части после корня числа либо ничего не останется (n = 1) либо мы гарантировано получим простое число
    (итогоое n - простое).
    Это удовлетворяет условию задачи (сложность корень из n). Решето эратосфена же по определению имеет сложность
    O(n log log n), так как мы физически не сможем пройтись до корня,
    потому что простые множители могут быть и после корня.
    Поэтому, алгоритм сложностью O(sqrt(n)) будет наиболее оптимальным.
    */
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

int main(){
    int n;
    cin >> n;
    int len = (int) sqrt(n) + 1;
    vector<int> delitels;
    for(int i = 2; i < len; i++){
        while(n > 1 && n % i == 0){
            n /= i;
            delitels.push_back(i);
        }
        if(n == 1){
            break;
        }
    }
    //проверка, осталось ли простое число после корня:
    if(n != 1){
        delitels.push_back(n);
    }
    //если нет делителей (пустой список), то число простое
    if (delitels.empty()) {
        cout << n << endl;
        return 0;
    }

    int a = delitels[0];
    int s = 1;
    // Выводим первый делитель
    cout << a;
    for (size_t i = 1; i < delitels.size(); i++) {
        if(a == delitels[i]){
            s++;
        }
        else{
            if(s > 1){
                cout << '^' << s;
            }
            //выводим * только если элемент не последний
            if(i < delitels.size()){
                cout << '*';
            }
            //когда a != delitels[i] меняем значение а:
            a = delitels[i];
            //выводим a:
            cout << a;
            //присваиваем 1 s:
            s = 1;
        }
    }

    // Обработка последнего делителя
    if(s > 1){
        cout << '^' << s << endl;
    } 

    return 0;
}

